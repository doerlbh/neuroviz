{
  "version": 3,
  "sources": ["../svelte-gestures/dist/index.esm.js"],
  "sourcesContent": ["const DEFAULT_DELAY = 300;\nconst DEFAULT_MIN_SWIPE_DISTANCE = 60; // in pixels\n\nconst DEFAULT_TOUCH_ACTION = 'none';\n\nfunction addEventListener(node, event, handler) {\n  node.addEventListener(event, handler);\n  return () => node.removeEventListener(event, handler);\n}\n\nfunction getCenterOfTwoPoints(node, activeEvents) {\n  const rect = node.getBoundingClientRect();\n  const xDistance = Math.abs(activeEvents[0].clientX - activeEvents[1].clientX);\n  const yDistance = Math.abs(activeEvents[0].clientY - activeEvents[1].clientY);\n  const minX = Math.min(activeEvents[0].clientX, activeEvents[1].clientX);\n  const minY = Math.min(activeEvents[0].clientY, activeEvents[1].clientY);\n  const centerX = minX + xDistance / 2;\n  const centerY = minY + yDistance / 2;\n  const x = Math.round(centerX - rect.left);\n  const y = Math.round(centerY - rect.top);\n  return {\n    x,\n    y\n  };\n}\n\nfunction removeEvent(event, activeEvents) {\n  return activeEvents.filter(activeEvent => {\n    return event.pointerId !== activeEvent.pointerId;\n  });\n}\n\nfunction dispatch(node, gestureName, event, activeEvents, pointerType) {\n  node.dispatchEvent(new CustomEvent(`${gestureName}${pointerType}`, {\n    detail: {\n      event,\n      pointersCount: activeEvents.length\n    }\n  }));\n}\n\nfunction setPointerControls(gestureName, node, onMoveCallback, onDownCallback, onUpCallback, touchAction = DEFAULT_TOUCH_ACTION) {\n  node.style.touchAction = touchAction;\n  let activeEvents = [];\n\n  function handlePointerdown(event) {\n    activeEvents.push(event);\n    dispatch(node, gestureName, event, activeEvents, 'down');\n    onDownCallback?.(activeEvents, event);\n    const pointerId = event.pointerId;\n\n    function onup(e) {\n      if (pointerId === e.pointerId) {\n        activeEvents = removeEvent(e, activeEvents);\n\n        if (!activeEvents.length) {\n          removeEventHandlers();\n        }\n\n        dispatch(node, gestureName, e, activeEvents, 'up');\n        onUpCallback?.(activeEvents, e);\n      }\n    }\n\n    function removeEventHandlers() {\n      removePointermoveHandler();\n      removeLostpointercaptureHandler();\n      removepointerupHandler();\n      removepointerleaveHandler();\n    }\n\n    const removePointermoveHandler = addEventListener(node, 'pointermove', e => {\n      activeEvents = activeEvents.map(activeEvent => {\n        return e.pointerId === activeEvent.pointerId ? e : activeEvent;\n      });\n      dispatch(node, gestureName, e, activeEvents, 'move');\n      onMoveCallback?.(activeEvents, e);\n    });\n    const removeLostpointercaptureHandler = addEventListener(node, 'lostpointercapture', e => {\n      onup(e);\n    });\n    const removepointerupHandler = addEventListener(node, 'pointerup', e => {\n      onup(e);\n    });\n    const removepointerleaveHandler = addEventListener(node, 'pointerleave', e => {\n      activeEvents = [];\n      removeEventHandlers();\n      dispatch(node, gestureName, e, activeEvents, 'up');\n      onUpCallback?.(activeEvents, e);\n    });\n  }\n\n  const removePointerdownHandler = addEventListener(node, 'pointerdown', handlePointerdown);\n  return {\n    destroy: () => {\n      removePointerdownHandler();\n    }\n  };\n}\n\nfunction pan(node, parameters = {\n  delay: DEFAULT_DELAY\n}) {\n  const gestureName = 'pan';\n  let startTime;\n  let target;\n\n  function onDown(activeEvents, event) {\n    startTime = Date.now();\n    target = event.target;\n  }\n\n  function onMove(activeEvents, event) {\n    if (activeEvents.length === 1 && Date.now() - startTime > parameters.delay) {\n      const rect = node.getBoundingClientRect();\n      const x = Math.round(event.clientX - rect.left);\n      const y = Math.round(event.clientY - rect.top);\n\n      if (x >= 0 && y >= 0 && x <= rect.width && y <= rect.height) {\n        node.dispatchEvent(new CustomEvent(gestureName, {\n          detail: {\n            x,\n            y,\n            target\n          }\n        }));\n      }\n    }\n  }\n\n  return setPointerControls(gestureName, node, onMove, onDown, null);\n}\n\nfunction getPointersDistance(activeEvents) {\n  return Math.hypot(activeEvents[0].clientX - activeEvents[1].clientX, activeEvents[0].clientY - activeEvents[1].clientY);\n}\n\nfunction pinch(node) {\n  const gestureName = 'pinch';\n  let prevDistance = null;\n  let initDistance = 0;\n  let pinchCenter;\n\n  function onUp(activeEvents) {\n    if (activeEvents.length === 1) {\n      prevDistance = null;\n    }\n  }\n\n  function onDown(activeEvents) {\n    if (activeEvents.length === 2) {\n      initDistance = getPointersDistance(activeEvents);\n      pinchCenter = getCenterOfTwoPoints(node, activeEvents);\n    }\n  }\n\n  function onMove(activeEvents) {\n    if (activeEvents.length === 2) {\n      const curDistance = getPointersDistance(activeEvents);\n\n      if (prevDistance !== null && curDistance !== prevDistance) {\n        const scale = curDistance / initDistance;\n        node.dispatchEvent(new CustomEvent(gestureName, {\n          detail: {\n            scale,\n            center: pinchCenter\n          }\n        }));\n      }\n\n      prevDistance = curDistance;\n    }\n  }\n\n  return setPointerControls(gestureName, node, onMove, onDown, onUp);\n}\n\nfunction press(node, parameters) {\n  parameters = {\n    timeframe: DEFAULT_DELAY,\n    triggerBeforeFinished: false,\n    ...parameters\n  };\n  node.style.userSelect = 'none';\n\n  node.oncontextmenu = e => {\n    e.preventDefault();\n  };\n\n  const gestureName = 'press';\n  let startTime;\n  let clientX;\n  let clientY;\n  let clientMoved = {\n    x: 0,\n    y: 0\n  };\n  let timeout;\n  let triggeredOnTimeout = false;\n\n  function onUp(activeEvents, event) {\n    clearTimeout(timeout);\n\n    if (!triggeredOnTimeout) {\n      onDone(event.clientX, event.clientY, event);\n    }\n  }\n\n  function onMove(activeEvents, event) {\n    clientMoved.x = event.clientX;\n    clientMoved.y = event.clientY;\n  }\n\n  function onDown(activeEvents, event) {\n    clientX = event.clientX;\n    clientY = event.clientY;\n    startTime = Date.now();\n    triggeredOnTimeout = false;\n\n    if (parameters.triggerBeforeFinished) {\n      timeout = setTimeout(() => {\n        triggeredOnTimeout = true;\n        clientMoved.x = event.clientX;\n        clientMoved.y = event.clientY;\n        onDone(clientMoved.x, clientMoved.y, event);\n      }, parameters.timeframe + 1);\n    }\n  }\n\n  function onDone(eventX, eventY, event) {\n    if (Math.abs(eventX - clientX) < 4 && Math.abs(eventY - clientY) < 4 && Date.now() - startTime > parameters.timeframe) {\n      const rect = node.getBoundingClientRect();\n      const x = Math.round(eventX - rect.left);\n      const y = Math.round(eventY - rect.top);\n      node.dispatchEvent(new CustomEvent(gestureName, {\n        detail: {\n          x,\n          y,\n          target: event.target\n        }\n      }));\n    }\n  }\n\n  const onSharedDestroy = setPointerControls(gestureName, node, onMove, onDown, onUp);\n  return {\n    destroy: () => {\n      onSharedDestroy.destroy();\n      clearTimeout(timeout);\n    }\n  };\n}\n\nfunction getPointersAngleDeg(activeEvents) {\n  // instead of hell lot of conditions we use an object mapping\n  const quadrantsMap = {\n    left: {\n      top: 360,\n      bottom: 180\n    },\n    right: {\n      top: 0,\n      bottom: 180\n    }\n  };\n  const width = activeEvents[1].clientX - activeEvents[0].clientX;\n  const height = activeEvents[0].clientY - activeEvents[1].clientY;\n  /*\n  In quadrants 1 and 3 allworks as expected. \n  In quadrants 2 and 4, either height or width is negative,\n  so we get negative angle. It is even the other of the two angles.\n  As sum in triangle is 180 deg, we can simply sum the negative angle with 90 deg\n  and get the right angle's positive value. Then add 90 for each quadrant above 1st.\n  This way we dont need to code our own arc cotangent fn (it does not exist in JS)\n  */\n\n  const angle = Math.atan(width / height) / (Math.PI / 180);\n  const halfQuadrant = width > 0 ? quadrantsMap.right : quadrantsMap.left;\n  const quadrantAngleBonus = height > 0 ? halfQuadrant.top : halfQuadrant.bottom;\n  return angle + quadrantAngleBonus;\n}\n\nfunction rotate(node) {\n  const gestureName = 'rotate';\n  let prevAngle = null;\n  let initAngle = 0;\n  let rotationCenter;\n\n  function onUp(activeEvents) {\n    if (activeEvents.length === 1) {\n      prevAngle = null;\n    }\n  }\n\n  function onDown(activeEvents) {\n    if (activeEvents.length === 2) {\n      activeEvents = activeEvents.sort((a, b) => {\n        return a.clientX - b.clientX;\n      });\n      rotationCenter = getCenterOfTwoPoints(node, activeEvents);\n      initAngle = getPointersAngleDeg(activeEvents);\n    }\n  }\n\n  function onMove(activeEvents) {\n    if (activeEvents.length === 2) {\n      const curAngle = getPointersAngleDeg(activeEvents);\n\n      if (prevAngle !== null && curAngle !== prevAngle) {\n        // Make sure we start at zero, doesnt matter what is the initial angle of fingers\n        let rotation = curAngle - initAngle; // instead of showing 180 - 360, we will show negative -180 - 0\n\n        if (rotation > 180) {\n          rotation -= 360;\n        }\n\n        node.dispatchEvent(new CustomEvent(gestureName, {\n          detail: {\n            rotation,\n            center: rotationCenter\n          }\n        }));\n      }\n\n      prevAngle = curAngle;\n    }\n  }\n\n  return setPointerControls(gestureName, node, onMove, onDown, onUp);\n}\n\nfunction swipe(node, parameters = {\n  timeframe: DEFAULT_DELAY,\n  minSwipeDistance: DEFAULT_MIN_SWIPE_DISTANCE,\n  touchAction: DEFAULT_TOUCH_ACTION\n}) {\n  const gestureName = 'swipe';\n  let startTime;\n  let clientX;\n  let clientY;\n  let target;\n\n  function onDown(activeEvents, event) {\n    clientX = event.clientX;\n    clientY = event.clientY;\n    startTime = Date.now();\n\n    if (activeEvents.length === 1) {\n      target = event.target;\n    }\n  }\n\n  function onUp(activeEvents, event) {\n    if (event.type === 'pointerup' && activeEvents.length === 0 && Date.now() - startTime < parameters.timeframe) {\n      const x = event.clientX - clientX;\n      const y = event.clientY - clientY;\n      const absX = Math.abs(x);\n      const absY = Math.abs(y);\n      let direction = null;\n\n      if (absX >= 2 * absY && absX > parameters.minSwipeDistance) {\n        // horizontal (by *2 we eliminate diagonal movements)\n        direction = x > 0 ? 'right' : 'left';\n      } else if (absY >= 2 * absX && absY > parameters.minSwipeDistance) {\n        // vertical (by *2 we eliminate diagonal movements)\n        direction = y > 0 ? 'bottom' : 'top';\n      }\n\n      if (direction) {\n        node.dispatchEvent(new CustomEvent(gestureName, {\n          detail: {\n            direction,\n            target\n          }\n        }));\n      }\n    }\n  }\n\n  return setPointerControls(gestureName, node, null, onDown, onUp, parameters.touchAction);\n}\n\nfunction tap(node, parameters = {\n  timeframe: DEFAULT_DELAY\n}) {\n  const gestureName = 'tap';\n  let startTime;\n  let clientX;\n  let clientY;\n\n  function onUp(activeEvents, event) {\n    if (Math.abs(event.clientX - clientX) < 4 && Math.abs(event.clientY - clientY) < 4 && Date.now() - startTime < parameters.timeframe) {\n      const rect = node.getBoundingClientRect();\n      const x = Math.round(event.clientX - rect.left);\n      const y = Math.round(event.clientY - rect.top);\n      node.dispatchEvent(new CustomEvent(gestureName, {\n        detail: {\n          x,\n          y,\n          target: event.target\n        }\n      }));\n    }\n  }\n\n  function onDown(activeEvents, event) {\n    clientX = event.clientX;\n    clientY = event.clientY;\n    startTime = Date.now();\n  }\n\n  return setPointerControls(gestureName, node, null, onDown, onUp);\n}\n\nexport { DEFAULT_DELAY, DEFAULT_MIN_SWIPE_DISTANCE, DEFAULT_TOUCH_ACTION, getCenterOfTwoPoints, pan, pinch, press, rotate, setPointerControls, swipe, tap };\n"],
  "mappings": "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",
  "names": []
}
